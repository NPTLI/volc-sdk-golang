// Code generated by protoc-gen-volcengine-sdk
// source: PullToPushTaskService
// DO NOT EDIT!

package live

import (
	"encoding/json"
	"net/http"
	"net/url"

	"google.golang.org/protobuf/encoding/protojson"

	"github.com/pkg/errors"

	"github.com/volcengine/volc-sdk-golang/service/live/models/request"
	"github.com/volcengine/volc-sdk-golang/service/live/models/response"
)

// CreatePullToPushTask
/*
 * @param *request.CreatePullToPushTaskRequest
 * @return *response.CreatePullToPushTaskResponse, int, error
 */
func (p *Live) CreatePullToPushTask(req *request.CreatePullToPushTaskRequest) (*response.CreatePullToPushTaskResponse, int, error) {
	body, err := json.Marshal(req)
	if err != nil {
		return nil, http.StatusBadRequest, err
	}
	respBody, status, err := p.Json("CreatePullToPushTask", url.Values{}, string(body))
	output := &response.CreatePullToPushTaskResponse{}
	unmarshaler := protojson.UnmarshalOptions{
		DiscardUnknown: true,
	}
	errUnmarshal := unmarshaler.Unmarshal(respBody, output)
	if err != nil || status != http.StatusOK {
		// if exist http err,check whether the respBody's type is defined struct,
		// if it is ,
		// return struct,
		// otherwise return nil body
		// if httpCode is not 200,check whether the respBody's type is defined struct,
		// if it is ,
		// use errorCode as err and return struct,
		// otherwise use respBody string as error and return
		if errUnmarshal != nil || len(output.GetResponseMetadata().GetError().GetCode()) == 0 {
			if err == nil {
				err = errors.New(string(respBody))
			}
			return nil, status, err
		} else {
			return output, status, errors.New(output.GetResponseMetadata().GetError().GetCode())
		}
	}
	return output, status, nil
}

// ListPullToPushTask
/*
 * @param *request.ListPullToPushTaskRequest
 * @return *response.ListPullToPushTaskResponse, int, error
 */
func (p *Live) ListPullToPushTask(req *request.ListPullToPushTaskRequest) (*response.ListPullToPushTaskResponse, int, error) {
	body, err := json.Marshal(req)
	if err != nil {
		return nil, http.StatusBadRequest, err
	}
	respBody, status, err := p.Json("ListPullToPushTask", url.Values{}, string(body))
	output := &response.ListPullToPushTaskResponse{}
	unmarshaler := protojson.UnmarshalOptions{
		DiscardUnknown: true,
	}
	errUnmarshal := unmarshaler.Unmarshal(respBody, output)
	if err != nil || status != http.StatusOK {
		// if exist http err,check whether the respBody's type is defined struct,
		// if it is ,
		// return struct,
		// otherwise return nil body
		// if httpCode is not 200,check whether the respBody's type is defined struct,
		// if it is ,
		// use errorCode as err and return struct,
		// otherwise use respBody string as error and return
		if errUnmarshal != nil || len(output.GetResponseMetadata().GetError().GetCode()) == 0 {
			if err == nil {
				err = errors.New(string(respBody))
			}
			return nil, status, err
		} else {
			return output, status, errors.New(output.GetResponseMetadata().GetError().GetCode())
		}
	}
	return output, status, nil
}

// UpdatePullToPushTask
/*
 * @param *request.UpdatePullToPushTaskRequest
 * @return *response.UpdatePullToPushTaskResponse, int, error
 */
func (p *Live) UpdatePullToPushTask(req *request.UpdatePullToPushTaskRequest) (*response.UpdatePullToPushTaskResponse, int, error) {
	body, err := json.Marshal(req)
	if err != nil {
		return nil, http.StatusBadRequest, err
	}
	respBody, status, err := p.Json("UpdatePullToPushTask", url.Values{}, string(body))
	output := &response.UpdatePullToPushTaskResponse{}
	unmarshaler := protojson.UnmarshalOptions{
		DiscardUnknown: true,
	}
	errUnmarshal := unmarshaler.Unmarshal(respBody, output)
	if err != nil || status != http.StatusOK {
		// if exist http err,check whether the respBody's type is defined struct,
		// if it is ,
		// return struct,
		// otherwise return nil body
		// if httpCode is not 200,check whether the respBody's type is defined struct,
		// if it is ,
		// use errorCode as err and return struct,
		// otherwise use respBody string as error and return
		if errUnmarshal != nil || len(output.GetResponseMetadata().GetError().GetCode()) == 0 {
			if err == nil {
				err = errors.New(string(respBody))
			}
			return nil, status, err
		} else {
			return output, status, errors.New(output.GetResponseMetadata().GetError().GetCode())
		}
	}
	return output, status, nil
}

// StopPullToPushTask
/*
 * @param *request.StopPullToPushTaskRequest
 * @return *response.StopPullToPushTaskResponse, int, error
 */
func (p *Live) StopPullToPushTask(req *request.StopPullToPushTaskRequest) (*response.StopPullToPushTaskResponse, int, error) {
	body, err := json.Marshal(req)
	if err != nil {
		return nil, http.StatusBadRequest, err
	}
	respBody, status, err := p.Json("StopPullToPushTask", url.Values{}, string(body))
	output := &response.StopPullToPushTaskResponse{}
	unmarshaler := protojson.UnmarshalOptions{
		DiscardUnknown: true,
	}
	errUnmarshal := unmarshaler.Unmarshal(respBody, output)
	if err != nil || status != http.StatusOK {
		// if exist http err,check whether the respBody's type is defined struct,
		// if it is ,
		// return struct,
		// otherwise return nil body
		// if httpCode is not 200,check whether the respBody's type is defined struct,
		// if it is ,
		// use errorCode as err and return struct,
		// otherwise use respBody string as error and return
		if errUnmarshal != nil || len(output.GetResponseMetadata().GetError().GetCode()) == 0 {
			if err == nil {
				err = errors.New(string(respBody))
			}
			return nil, status, err
		} else {
			return output, status, errors.New(output.GetResponseMetadata().GetError().GetCode())
		}
	}
	return output, status, nil
}

// RestartPullToPushTask
/*
 * @param *request.RestartPullToPushTaskRequest
 * @return *response.RestartPullToPushTaskResponse, int, error
 */
func (p *Live) RestartPullToPushTask(req *request.RestartPullToPushTaskRequest) (*response.RestartPullToPushTaskResponse, int, error) {
	body, err := json.Marshal(req)
	if err != nil {
		return nil, http.StatusBadRequest, err
	}
	respBody, status, err := p.Json("RestartPullToPushTask", url.Values{}, string(body))
	output := &response.RestartPullToPushTaskResponse{}
	unmarshaler := protojson.UnmarshalOptions{
		DiscardUnknown: true,
	}
	errUnmarshal := unmarshaler.Unmarshal(respBody, output)
	if err != nil || status != http.StatusOK {
		// if exist http err,check whether the respBody's type is defined struct,
		// if it is ,
		// return struct,
		// otherwise return nil body
		// if httpCode is not 200,check whether the respBody's type is defined struct,
		// if it is ,
		// use errorCode as err and return struct,
		// otherwise use respBody string as error and return
		if errUnmarshal != nil || len(output.GetResponseMetadata().GetError().GetCode()) == 0 {
			if err == nil {
				err = errors.New(string(respBody))
			}
			return nil, status, err
		} else {
			return output, status, errors.New(output.GetResponseMetadata().GetError().GetCode())
		}
	}
	return output, status, nil
}

// DeletePullToPushTask
/*
 * @param *request.DeletePullToPushTaskRequest
 * @return *response.DeletePullToPushTaskResponse, int, error
 */
func (p *Live) DeletePullToPushTask(req *request.DeletePullToPushTaskRequest) (*response.DeletePullToPushTaskResponse, int, error) {
	body, err := json.Marshal(req)
	if err != nil {
		return nil, http.StatusBadRequest, err
	}
	respBody, status, err := p.Json("DeletePullToPushTask", url.Values{}, string(body))
	output := &response.DeletePullToPushTaskResponse{}
	unmarshaler := protojson.UnmarshalOptions{
		DiscardUnknown: true,
	}
	errUnmarshal := unmarshaler.Unmarshal(respBody, output)
	if err != nil || status != http.StatusOK {
		// if exist http err,check whether the respBody's type is defined struct,
		// if it is ,
		// return struct,
		// otherwise return nil body
		// if httpCode is not 200,check whether the respBody's type is defined struct,
		// if it is ,
		// use errorCode as err and return struct,
		// otherwise use respBody string as error and return
		if errUnmarshal != nil || len(output.GetResponseMetadata().GetError().GetCode()) == 0 {
			if err == nil {
				err = errors.New(string(respBody))
			}
			return nil, status, err
		} else {
			return output, status, errors.New(output.GetResponseMetadata().GetError().GetCode())
		}
	}
	return output, status, nil
}
